# Prompt: Write docs like this repo

You are an expert engineer writing hand-written, highly practical developer docs for a Python project.

## Goal

Create a small set of Markdown guides in `docs/` that match this house style:

- Concise, deterministic, “no marketing”
- Curated (not autogenerated API docs)
- Example-first (small YAML/Python/CLI snippets)
- Bullets + short paragraphs, minimal prose
- Explicit contracts/validation rules and failure modes
- Clear separation between “compile/build-time” vs “runtime/execution”, if applicable

## Repo assumptions

- Python ≥ 3.13, `src/` layout
- Tooling: `uv`, `Taskfile`, `ruff` (format+lint), `ty` (types), `pytest`
- Follow `AGENTS.md` conventions for tone and engineering rigor

## Process (do this, don’t guess)

1. Read `AGENTS.md`, `Taskfile.yml`, `pyproject.toml`, and the CLI entrypoint(s).
2. Identify the project’s primary workflow(s): inputs → transformations → artifacts → runtime execution.
3. Enumerate the “public surface area”: CLI commands, runtime entrypoint(s), and a curated list of importable functions/types.
4. Extract the actual configuration formats (YAML/JSON/TOML/etc) from code and/or schemas; document fields + defaults + validation rules.
5. Collect common failures from exceptions/messages and tests; write a troubleshooting guide keyed by recognizable error text.

## Output files

Create these files under `docs/` (keep each file tight; prefer ≤ ~120 lines unless truly necessary):

- `docs/README.md`: 1-paragraph purpose + bullet list of guides (each with 1-line description).
- `docs/overview.md`: what the project does + end-to-end flow + core concepts glossary (short bullets).
- `docs/architecture.md`: deterministic pipeline description, key phases, artifact/output layout (tree), naming/metadata rules, integration points.
- `docs/<config-spec>.md` (one or more): “Structure” section with a full minimal example, then “Fields” bullets, then “Rules and validation”.
- `docs/runtime.md`: how it runs in the target environment (local/CI/cloud), entrypoints + args, typical execution flow, what it does NOT do.
- `docs/testing.md`: test tiers (unit/integration), what to test, and how to run via Taskfile (show `task test` etc).
- `docs/troubleshooting.md`: symptom → cause → fix; include quoted-ish error strings as headings/bullets when available.
- `docs/api-reference.md`: curated list of CLI entrypoints + key Python functions/types (names only + 1-line intent; no exhaustive listing).

## Style rules (match exactly)

- Use Markdown headers: `#`, `##`, occasional `###` only.
- Prefer lists over paragraphs; paragraphs max 2–3 sentences.
- Include at least one “Structure” code block for each spec doc (YAML/JSON/etc).
- Use explicit names/paths and concrete examples (`task test`, `uv run ...`, `package.module:main`).
- When behavior is conditional, state the condition and the outcome (“If X, compiler fails/skips…”).
- Don’t invent features/flags. If unknown, write “Not supported” or omit.
- Keep terminology consistent across pages (define once in overview, reuse).

## Acceptance checklist (self-verify before finishing)

- A new engineer can run the primary workflow using only these docs.
- Specs list required vs optional fields and validation rules.
- Troubleshooting covers the top 5 realistic failure modes.
- API reference is curated and matches real symbols/commands.
- Commands use Taskfile/uv conventions; no alternate tooling suggested.

